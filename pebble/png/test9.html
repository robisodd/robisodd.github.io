<!DOCTYPE html>
<!-- http://meyerweb.com/eric/thoughts/2007/05/01/reset-reloaded/ -->
<!-- Dithering From: https://github.com/dpiccone/ditherjs -->

<html style="height:100%;">
	<head>
		<style>
			* {
				margin: 0;
				padding: 0;
			}

			table {
				border-collapse: collapse;
			}
	
			input[type=range] {
				-webkit-appearance: none;
				background-color: silver;
				width: 75%;
				height:50px;
			}

			input[type="range"]::-webkit-slider-thumb {
				 -webkit-appearance: none;
				background-color: #666;
				opacity: 0.5;
				width: 50px;
				height: 50px;
			}
			
			canvas {
				image-rendering: pixelated;
				border-radius: 6px;
			}
			
			#watchBody {
				width: 244px;
				padding: 91px 0px;
				background: url(http://pebble.github.io/rockyjs/img/basaltLight.png) no-repeat;
			}
		</style>
	</head>
	<body onload="load_url();" style="height:100%;">
		<center>
		
			WEE<input type="range" min="-255" max="255" value="0" step="1"/><br>
		
			<div id="content" style="height:100%; width:100%; background:blue;">
				<div id="toparea" style="width:100%; background:red;">
					<form>
						URL:<input type="text" id="theurl" value="https://i.imgur.com/N377J99.png"><br><!-- http://files.enjin.com.s3.amazonaws.com/272093/modules/forum/attachments/10th+Doctor+BROWN_1397583069.jpg"><br> -->
						<input type="submit" id="update_button" value="Load URL and Reset"><br>
						<input type="checkbox" onclick="set_zoom(this.checked);"/>Zoom
						<input type="checkbox" onclick="set_fuzzy(this.checked);"/>Fuzzy
						<br>
						Dithering:
						<input type="radio" name="dithering" id="dither_none" onclick="update_dither_mode(0);">None
						<input type="radio" name="dithering" id="dither_ordered" onclick="update_dither_mode(1);">Rob Ordered
						<input type="radio" name="dithering" id="dither_atkinson" onclick="update_dither_mode(2);" checked>Rob Atkinson
						<input type="radio" name="dithering" id="dither_diffusion" onclick="update_dither_mode(3);">Diffusion
						<input type="radio" name="dithering" id="dither_atkinson" onclick="update_dither_mode(4);">Old Ordered
						<input type="radio" name="dithering" id="dither_atkinson" onclick="update_dither_mode(5);">Old Atkinson
						<input type="radio" name="dithering" id="dither_diffusion" onclick="update_dither_mode(6);">Old Diffusion
						<br>
						Colors:
						<input type="radio" name="color_mode" id="color_bw" onclick="update_color(0);" checked>B&W
						<input type="radio" name="color_mode" id="color_64" onclick="update_color(1);">64-Color
						<input type="radio" name="color_mode" id="greyscale" onclick="update_color(2);">Greyscale
						<br>
						Brightness: <input type="range" min="-255" max="255" value="0" step="1" oninput="set_brightness(this.value)" /><span id="brightness">0</span><br>
						Contrast:   <input type="range" min="-255" max="255" value="0" step="1" oninput="set_contrast(this.value)" /><span id="contrast">0</span><br>
					</form>
				</div>
				<div id="lowerarea" style="background:blue; width:'100%'">
					<div id="watchBody">
						<canvas id="mainCanvas" width="144" height="168" style="border:1px solid #d3d3d3;">Your browser does not support the HTML5 canvas tag.</canvas>
					</div>
				</div>
			</div>
		</center>
		<script>
			var step = 1;
			
			bwpalette = [
				[0, 0, 0],
				[255, 255, 255]
			];
			var greyscale = [
				[0, 0, 0],
				[255, 255, 255],
				[85, 85, 85],
				[170, 170, 170]			
			];
			var colorpalette = [
				[0, 0, 0],
				[255, 255, 255],
				[85, 85, 85],
				[170, 170, 170],
				[170, 85, 0],
				[170, 85, 85],
				[170, 0, 0],
				[255, 0, 170],
				[255, 85, 170],
				[255, 170, 255],
				[255, 255, 0],
				[255, 170, 0],
				[255, 255, 85],
				[255, 170, 85],
				[255, 85, 0],
				[255, 0, 0],
				[255, 170, 170],
				[255, 85, 85],
				[255, 0, 85],
				[170, 170, 0],
				[85, 0, 0],
				[170, 0, 85],
				[255, 0, 255],
				[255, 85, 255],
				[170, 255, 85],
				[170, 255, 0],
				[170, 170, 85],
				[85, 85, 0],
				[85, 0, 85],
				[170, 0, 170],
				[170, 85, 170],
				[85, 255, 0],
				[85, 170, 0],
				[0, 85, 0],
				[0, 85, 85],
				[0, 0, 85],
				[85, 0, 170],
				[170, 0, 255],
				[170, 85, 255],
				[0, 255, 0],
				[0, 170, 0],
				[85, 170, 85],
				[85, 170, 170],
				[0, 85, 170],
				[0, 0, 170],
				[85, 0, 255],
				[85, 85, 170],
				[170, 255, 170],
				[85, 255, 85],
				[0, 255, 85],
				[0, 170, 85],
				[0, 170, 170],
				[0, 170, 255],
				[0, 0, 255],
				[85, 85, 255],
				[170, 170, 255],
				[85, 255, 170],
				[0, 255, 170],
				[0, 255, 255],
				[85, 170, 255],
				[0, 85, 255],
				[85, 255, 255],
				[170, 255, 255],
				[255, 255, 170]
			];
			
			var dithertimer;
			var brightness=0;
			var contrast=0;
			var zoom_mode = false;
			var fuzzy_mode = false;
			
				var mainCanvas= document.getElementById("mainCanvas");
				var mainCanvasCTX = document.getElementById("mainCanvas").getContext("2d");
				mainCanvasCTX.imageSmoothingEnabled = fuzzy_mode;
				var canvas_w = mainCanvas.width, canvas_h = mainCanvas.height;
				
				var toparea = document.getElementById("toparea");
				
				var lowerarea = document.getElementById("lowerarea");
				
			var image_x = 0, image_y = 0;
			var zoom = 1;	
			var mouse_x = 0, mouse_y = 0, finger_dist = 0;
			var dither_mode = 2;//document.getElementsByName("dithering");
			var  color_mode = 0;//document.getElementsByName("color_mode");
			var mouse_mode = 0;
			var background_color = "#00AAFF";
			
			var source_image_obj = new Image();
			source_image_obj.addEventListener('load', function() {image_loaded();}, false); // Reset (x,y,zoom) when new image loads
			
			function image_loaded() {
				console.log("Image Loaded from URL");
				reset_settings();
				//draw_original_image_to_mainCanvas();
				//dither_imageCanvas_onto_fixedCanvas();
				update_canvas();
			}
			
			function load_url() {
				// When image is finished loading from the source, image_loaded() is called (due to the "load" event listener above)
				console.log("loadurl");
				source_image_obj.crossOrigin = "Anonymous";
				source_image_obj.src = document.getElementById("theurl").value;
			}
			
			function update_canvas() {
				console.log("update canvas");
				draw_original_image_to_mainCanvas();
				adjust_mainCanvas();
				
				//clearTimeout(dithertimer); dithertimer = setTimeout(update_dither, 100);
				//update_dither();
			}
			
			function draw_original_image_to_mainCanvas() {
				// Keep picture in bounds
				if(image_x - (canvas_w * zoom / 2) > source_image_obj.width ) image_x = source_image_obj.width  + (canvas_w * zoom / 2);
				if(image_y - (canvas_h * zoom / 2) > source_image_obj.height) image_y = source_image_obj.height + (canvas_h * zoom / 2);
				if(image_x + (canvas_w * zoom / 2) < 0)                       image_x =                       0 - (canvas_w * zoom / 2);
				if(image_y + (canvas_h * zoom / 2) < 0)                       image_y =                       0 - (canvas_h * zoom / 2);
				// Draw the scaled image onto the canvas
				mainCanvasCTX.fillStyle=background_color;
				mainCanvasCTX.fillRect(0, 0, canvas_w, canvas_h);
				mainCanvasCTX.drawImage(source_image_obj, image_x - (canvas_w * zoom / 2), image_y - (canvas_h * zoom / 2), canvas_w * zoom, canvas_h * zoom, 0, 0, canvas_w, canvas_h);
			}
			
			function adjust_mainCanvas() {
				var imageData = mainCanvasCTX.getImageData(0, 0, canvas_w, canvas_h); // copies data
				var d = new Uint8ClampedArray(imageData.data.buffer); // d is a view (a pointer), doesn't copy data
				
				brightness_contrast(d, brightness, contrast);
				
				if(color_mode==0) {	// do b&w
					if(dither_mode==1) {	//ordered
						robOrderedDitherBW(d);
					} else if(dither_mode==2) {	//atkinson
						robAtkinsonDitherBW(d);
					} else if(dither_mode==3) {	//diffusion

					} else if(dither_mode==4) {	//Old Ordered
						imageData = DitherJS.orderedDither(imageData, mainCanvasCTX, bwpalette, step, 168, 144);
					} else if(dither_mode==5) {	//Old Atkinson
						imageData = DitherJS.atkinsonDitherOld(imageData, mainCanvasCTX, bwpalette, step, 168, 144);
					} else if(dither_mode==6) {	//Old Diffusion
						imageData = DitherJS.atkinsonDither(imageData, mainCanvasCTX, bwpalette, step, 168, 144);
					} else {					// no dither
						robClosestBW(d);
					}
				} else if(color_mode==1) {	// do 64color
					if(dither_mode==1) {	//ordered
						robOrderedDitherColor(d);
					} else if(dither_mode==2) {	//atkinson
						robAtkinsonDither(d);
					} else if(dither_mode==3) {	//diffusion
					
					} else if(dither_mode==4) {	//Old Ordered
						imageData = DitherJS.orderedDither(imageData, mainCanvasCTX, colorpalette, step, 168, 144);
					} else if(dither_mode==5) {	//Old Atkinson
						imageData = DitherJS.atkinsonDitherOld(imageData, mainCanvasCTX, colorpalette, step, 168, 144);
					} else if(dither_mode==6) {	//Old Diffusion
						imageData = DitherJS.atkinsonDither(imageData, mainCanvasCTX, colorpalette, step, 168, 144);
					} else {					// no dither
						robClosestColor(d);
					}
				} else if(color_mode==2) {	// do greyscale
					if(dither_mode==1) {	//ordered
						
					} else if(dither_mode==2) {	//atkinson

					} else if(dither_mode==3) {	//diffusion
						
					} else if(dither_mode==4) {	//Old Ordered
						imageData = DitherJS.orderedDither(imageData, mainCanvasCTX, greyscale, step, 168, 144);
					} else if(dither_mode==5) {	//Old Atkinson
						imageData = DitherJS.atkinsonDitherOld(imageData, mainCanvasCTX, greyscale, step, 168, 144);
					} else if(dither_mode==6) {	//Old Diffusion
						imageData = DitherJS.atkinsonDither(imageData, mainCanvasCTX, greyscale, step, 168, 144);
					} else {					// no dither
						
					}
				} else {
					// unknown color mode
				}
				
				if(zoom_mode) {
					robClosestColor(d);
				}
				
				
				
				//imageData.data.set(d);
				mainCanvasCTX.putImageData(imageData, 0, 0);
			}
			
			function dither_imageCanvas_onto_fixedCanvasX() {
				console.log("Start Brightness and Dithering");
				var out_image;
				var imageWidth  = source_image_obj.width;
				var imageHeight = source_image_obj.height;
				imageCanvas.width  = imageWidth;
				imageCanvas.height = imageHeight;
				imageCanvasCTX.clearRect(0, 0, imageWidth, imageHeight);
				imageCanvasCTX.drawImage(source_image_obj, 0, 0, imageWidth, imageHeight);
				
				
				console.log("Start Brightness/Contrast");
				//var in_image = brightness_contrast(imageCanvasCTX, brightness, contrast);
				brightness_contrast(imageCanvasCTX, brightness, contrast);
				
				
				//out_image = imageCanvasCTX.createImageData(in_image);
				

				
				//var in_image = imageCanvasCTX.getImageData(0, 0, imageWidth, imageHeight);
				
				console.log("Get Image");
				var main_in_image = imageCanvasCTX.getImageData(0, 0, imageWidth, imageHeight);
				console.log("Start Dithering");
out_image = DitherJS.atkinsonDither(main_in_image, imageCanvasCTX, bwpalette, step, imageHeight, imageWidth);
console.log("k");
/*
				if(color_mode==0) {	// do b&w
					if(dither_mode==1) {	//ordered
						out_image = DitherJS.orderedDither(in_image, imageCanvasCTX, bwpalette, step, imageHeight, imageWidth);
					} else if(dither_mode==2) {	//atkinson
						out_image = DitherJS.atkinsonDither(in_image, imageCanvasCTX, bwpalette, step, imageHeight, imageWidth);
					} else if(dither_mode==3) {	//diffusion
						out_image = DitherJS.errorDiffusionDither(in_image, imageCanvasCTX, bwpalette, step, imageHeight, imageWidth);
					} else {					// no dither
						out_image = DitherJS.closestColor(in_image, imageCanvasCTX, bwpalette, step, imageHeight, imageWidth);
					}
				} else if(color_mode==1) {	// do 64color
					if(dither_mode==1) {	//ordered
						out_image = DitherJS.orderedDither(in_image, imageCanvasCTX, colorpalette, step, imageHeight, imageWidth);
					} else if(dither_mode==2) {	//atkinson
						out_image = DitherJS.atkinsonDither(in_image, imageCanvasCTX, colorpalette, step, imageHeight, imageWidth);
					} else if(dither_mode==3) {	//diffusion
						out_image = DitherJS.errorDiffusionDither(in_image, imageCanvasCTX, colorpalette, step, imageHeight, imageWidth);
					} else {					// no dither
						out_image = DitherJS.closestColor(in_image, imageCanvasCTX, colorpalette, step, imageHeight, imageWidth);
					}
				} else if(color_mode==2) {	// do greyscale
					if(dither_mode==1) {	//ordered
						out_image = DitherJS.orderedDither(in_image, imageCanvasCTX, greyscale, step, imageHeight, imageWidth);
					} else if(dither_mode==2) {	//atkinson
						out_image = DitherJS.atkinsonDither(in_image, imageCanvasCTX, greyscale, step, imageHeight, imageWidth);
					} else if(dither_mode==3) {	//diffusion
						out_image = DitherJS.errorDiffusionDither(in_image, imageCanvasCTX, greyscale, step, imageHeight, imageWidth);
					} else {					// no dither
						out_image = DitherJS.closestColor(in_image, imageCanvasCTX, greyscale, step, imageHeight, imageWidth);
					}
				} else {
					out_image = imageCanvasCTX.createImageData(in_image);
				}
				*/
				console.log("Putting Image");
				imageCanvasCTX.putImageData(out_image, 0, 0);
				console.log("Dithering Complete");
			}
			
			function update_color(mode) {
				color_mode = parseInt(mode);
				update_canvas();
			}
			function update_dither_mode(mode) {
				dither_mode = parseInt(mode);
				update_canvas();
			}
			
			function set_zoom(value) {
				if(value==true) {
					zoom_mode = true;
				} else {
					zoom_mode = false;
				}
				update_canvas();
			}
			
			function set_fuzzy(value) {
				if(value==true) {
					fuzzy_mode = true;
				} else {
					fuzzy_mode = false;
				}
				mainCanvasCTX.imageSmoothingEnabled = fuzzy_mode;
				update_canvas();
			}
			

			function set_brightness(value) {
				brightness = parseInt(value);
				document.getElementById("brightness").innerHTML=parseInt(value);
				update_canvas();
			}
			
			function set_contrast(value) {
				contrast = parseInt(value);
				document.getElementById("contrast").innerHTML=parseInt(value);
				update_canvas();
			}
			
			function reset_settings() {
				image_x = source_image_obj.width  / 2;
				image_y = source_image_obj.height / 2;
				zoom = 1;
				//update_canvas();  // Draw the image in its new position
			}

			document.getElementById("update_button").addEventListener("click", function(e){
				e.preventDefault();
				load_url();
			});

			document.addEventListener('wheel', function(e) {
				e.preventDefault();												// Stop the window from moving
				if(e.deltaY<0){
					zoom = zoom * 1.5;
				} else {
					zoom = zoom / 1.5;
				}
				update_canvas();
			}, false);
/*
			document.addEventListener('mousemove', function(e) {
				if(e.buttons==0)
					mouse_mode = 0;
				if(mouse_mode === 0) {
					e.preventDefault();
					if(e.buttons>0) {
						image_x = image_x + zoom * (mouse_x - e.clientX);
						image_y = image_y + zoom * (mouse_y - e.clientY);
						update_canvas();							// draw the image in its new position
					}
				}
				mouse_x = e.clientX; mouse_y = e.clientY;	// Save for next time
			}, false);

			function get_distance(e) {
				var diffX = e.touches[0].clientX - e.touches[1].clientX;
				var diffY = e.touches[0].clientY - e.touches[1].clientY;
				return Math.sqrt(diffX * diffX + diffY * diffY);	// Pythagorean theorem
			}

			toparea.addEventListener('mousedown', function(e) {
				mouse_mode = 1;
			}, false);

			document.addEventListener('mouseup', function(e) {
				mouse_mode = 0;
			}, false);

			toparea.addEventListener('touchstart', function(e) {
				mouse_mode = 1;
			}, false);

			document.addEventListener('touchend', function(e) {
				e.preventDefault();
				mouse_mode = 0;
				mouse_x = e.touches[0].clientX; mouse_y = e.touches[0].clientY;	// could be down to 1 finger, back to moving image
			}, false);
			
			bottomarea.addEventListener('touchstart', function(e) {
				mouse_mode = 0;
				if(mouse_mode === 0) {
					e.preventDefault();
					if(e.touches.length > 1) {			// if multiple touches (pinch zooming)
						finger_dist = get_distance(e);		// Save current finger distance
					}									// Else just moving around
				}
				mouse_x = e.touches[0].clientX;		// Save finger position
				mouse_y = e.touches[0].clientY;		//
			}, false);

			document.addEventListener('touchmove', function(e) {
				if(mouse_mode === 0) {
					e.preventDefault();												// Stop the window from moving
					if(e.touches.length > 1) {										// If pinch-zooming
						var new_finger_dist = get_distance(e);							// Get current distance between fingers
						zoom = zoom * Math.abs(finger_dist / new_finger_dist);			// Zoom is proportional to change
						finger_dist = new_finger_dist;									// Save current distance for next time
					} else {														// Else just moving around
						image_x = image_x + (zoom * (mouse_x - e.touches[0].clientX));	// Move the image
						image_y = image_y + (zoom * (mouse_y - e.touches[0].clientY));	//
						mouse_x = e.touches[0].clientX;									// Save finger position for next time
						mouse_y = e.touches[0].clientY;									//
					}
					update_canvas();												// draw the new position
				}
			}, false);
*/
	
	function brightness_contrast(d, brightness, contrast) {
		var bAdjust, cAdjust;
		bAdjust = Math.floor(255 * (brightness / 255));
		cAdjust = (contrast + 255) / 255;
		cAdjust = cAdjust * cAdjust;

        for (var i = 0; i < d.length; i += 4) {
				// Brightness
				d[i  ] += brightness;
				d[i+1] += brightness;
				d[i+2] += brightness;
				
				// Contrast
				d[i  ] = (d[i  ]-128)*cAdjust + 128;
				d[i+1] = (d[i+1]-128)*cAdjust + 128;
				d[i+2] = (d[i+2]-128)*cAdjust + 128;
        }
	}
	
	
	function robClosestColor(d) {
        for (var i = 0; i < d.length; i += 4) {
            d[i]     = (d[i  ]>>>6)*85;
			d[i + 1] = (d[i+1]>>>6)*85;
			d[i + 2] = (d[i+2]>>>6)*85;
        }
    };
	
	function robClosestBW(d) {
        for (var i = 0; i < d.length; i += 4) {
			var r = d[i], g = d[i+1], b = d[i+2];
			var y = ((r+r+r+b+g+g+g+g)>>>10)*255;
            d[i  ] = d[i+1] = d[i+2] = y;
        }
    };
	
    function robAtkinsonDither(d) {
		var approx_r, approx_g, approx_b, r, g, b, fw, n;
		fw = 4*canvas_w;
		for (var i = 0; i < d.length; i += 4) {

				approx_r = (d[i  ]>>>6)*85;
				approx_g = (d[i+1]>>>6)*85;
				approx_b = (d[i+2]>>>6)*85;
				
                r = (d[i  ] - approx_r) >> 3;
                g = (d[i+1] - approx_g) >> 3;
                b = (d[i+2] - approx_b) >> 3;
	
				// Diffuse the error for three colors
				n = i + 4;
                d[n   ] += r;
                d[n+ 1] += g;
                d[n+ 2] += b;

                d[n+ 4] += r;
                d[n+ 5] += g;
                d[n+ 6] += b;
				
				n = n + fw - 4;
				
                d[n   ] += r;
                d[n+ 1] += g;
                d[n+ 2] += b;

                d[n+ 4] += r;
                d[n+ 5] += g;
                d[n+ 6] += b;

                d[n+ 8] += r;
                d[n+ 9] += g;
                d[n+10] += b;
				
				n = n + fw + 8;
				
                d[n   ] += r;
                d[n+ 1] += g;
                d[n+ 2] += b;

				// Draw pixel
				d[i  ] = approx_r;
				d[i+1] = approx_g;
				d[i+2] = approx_b;
            }
    };
	
	function robAtkinsonDitherBW(d) {
		var r, g, b, fw, y, n;
		fw = 4*canvas_w;
		for (var i = 0; i < d.length; i += 4) {

				r = d[i  ];
				g = d[i+1];
				b = d[i+2];
				y = ((r+r+r+b+g+g+g+g)>>>10)*255;

                r = (r - y) >> 3;
                g = (g - y) >> 3;
                b = (b - y) >> 3;
	
				// Diffuse the error for three colors
				n = i + 4;
                d[i+4] += r;
                d[i+5] += g;
                d[i+6] += b;

                d[i+8] += r;
                d[i+9] += g;
                d[i+10] += b;
				
				n = n + fw - 4;
				
                d[i+fw] += r;
                d[i+fw+1] += g;
                d[i+fw+ 2] += b;

                d[i+fw+ 4] += r;
                d[i+fw+ 5] += g;
                d[i+fw+ 6] += b;

                d[i+fw+ 8] += r;
                d[i+fw+ 9] += g;
                d[i+fw+10] += b;
				
				n = n + fw + 8;
				
                d[i+fw+fw+8   ] += r;
                d[i+fw+fw+9] += g;
                d[i+fw+fw+10] += b;

				// Draw pixel
				d[i  ] = d[i+1] = d[i+2] = y;
            }
    };
	
	
    function robOrderedDitherColor(d) {
		var m, r, g, b, i, tr, tg, tb, di;

		const ratio = 16;
        ma= new Array(
            [  -128,  16,  -96, 48 ],
            [ 80,  -64, 112,  -32 ],
            [  -80, 64,  -112, 32 ],
            [ 128,  -16, 96,  -48]
        );
		mb = new Array(
            [  -256,  32,  -192, 96 ],
            [ 160,  -128, 224,  -64 ],
            [  -160, 128,  -224, 64 ],
            [ 256,  -32, 192,  -96]
        );
		const t=2;
        m = new Array(
            [-8*t, 1*t,-6*t, 3*t],
            [ 5*t,-4*t, 7*t,-2*t],
            [-5*t, 4*t,-7*t, 2*t],
            [ 8*t,-1*t, 6*t,-3*t]
        );
		//const ratio = 16;
        anm = new Array(
            [  1* ratio,  9* ratio,  3* ratio, 11* ratio ],
            [ 13* ratio,  5* ratio, 15* ratio,  7* ratio ],
            [  4* ratio, 12* ratio,  2* ratio, 10* ratio ],
            [ 16* ratio,  8* ratio, 14* ratio,  6* ratio ]
        );
		//128 - 
		
		mmm = new Array(
            [8-  1,8-  9,8-  3,8- 11 ],
            [8- 13,8-  5,8- 15,8-  7 ],
            [8-  4,8- 12,8-  2,8- 10 ],
            [8- 16,8-  8,8- 14,8-  6 ]
        );

        for (var y=0;y<canvas_h;y += 1) {
            for (var x=0;x<canvas_w;x += 1) {
                i = (4*x) + (4*y*canvas_w);

                // Define bytes
                r = i;
                g = i+1;
                b = i+2;
				v = m[x%4][y%4];

                d[r] += v;
                d[g] += v;
                d[b] += v;

				d[r] = (d[r]>>>6)*85;
				d[g] = (d[g]>>>6)*85;
				d[b] = (d[b]>>>6)*85;
            }
        }
    };
	
    function robOrderedDitherBW(d) {
		var m, r, g, b, i, tr, tg, tb, di;

		const ratio = 3;
        m = new Array(
            [  1* ratio,  9* ratio,  3* ratio, 11* ratio ],
            [ 13* ratio,  5* ratio, 15* ratio,  7* ratio ],
            [  4* ratio, 12* ratio,  2* ratio, 10* ratio ],
            [ 16* ratio,  8* ratio, 14* ratio,  6* ratio ]
        );

        for (var y=0;y<canvas_h;y += 1) {
            for (var x=0;x<canvas_w;x += 1) {
                i = (4*x) + (4*y*canvas_w);
                d[i  ] += m[x%4][y%4];
                d[i+1] += m[x%4][y%4];
                d[i+2] += m[x%4][y%4];

				lum = ((d[i]*3 + d[i+2] + d[i+1]*4)>>>10)*255;

				d[i] = d[i+1] = d[i+2] = lum;//((d[i]*3 + d[i+2] + d[i+1]*4)>>>10)*255;
            }
        }
    };
	function floydSteinberg(sb, w, h) {   // source buffer, width, height
		for(var i=0; i<h; i++) {
			for(var j=0; j<w; j++) {
				var ci = i*w+j;               // current buffer index
				var cc = sb[ci];              // current color
				var rc = (cc<128?0:255);      // real (rounded) color
				var err = cc-rc;              // error amount
				sb[ci] = rc;                  // saving real color
				if(j+1<w) sb[ci  +1] += (err*7)>>4;  // if right neighbour exists
				if(i+1==h) continue;   // if we are in the last line
				if(j  >0) sb[ci+w-1] += (err*3)>>4;  // bottom left neighbour
				sb[ci+w  ] += (err*5)>>4;  // bottom neighbour
				if(j+1<w) sb[ci+w+1] += (err*1)>>4;  // bottom right neighbour
			}
		}
	}
	
	
	/*
	
  var ratio = Math.min(144 / width,168 / height);
  var ratio = Math.min(ratio,1);

  var final_width = Math.floor(width * ratio);
  var final_height = Math.floor(height * ratio);
  var final_pixels = [];
  var bitmap = [];
	    var png = generatePngForPebble(final_width, final_height, final_pixels);
    for(var i=0; i<png.length; i++){
      bitmap.push(png.charCodeAt(i));
    }
  }

  return bitmap;
*/
		</script>
		
		
		
		
		<script>
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ //

		/**
* Javascript dithering library
* @author 2014 Daniele Piccone
* @author www.danielepiccone.com
* */

"use strict";

/**
* Process a series of img elements and make them canvas graphics
*
* @param selector - the selector of the elements to process
* @param opt - the options object
*/

var DitherJS = (function (window) {

    /**
    * Return a distance of two colors ina three dimensional space
    * @param array
    * @param array
    * @return number
    * */
    function colorDistance(a,b) {
        //if (a == null) return b;
        //if (b == null) return a;
        return Math.sqrt(
            Math.pow( ((a[0]) - (b[0])),2 )
            + Math.pow( ((a[1]) - (b[1])),2 )
            + Math.pow( ((a[2]) - (b[2])),2 )
        );
    };

    /**
    * Return the most closer color vs a common palette
    * @param array - the color
    * @return i - the index of the coloser color
    * */
    function approximateColor(color, palette) {
        var findIndex = function(fun,arg,list,min) {
            if (list.length == 2) {
                if (fun(arg,min) <= fun(arg,list[1])) {
                    return min;
                }else {
                    return list[1];
                }
            } else {
                //var hd = list[0];
                var tl = list.slice(1);
                if (fun(arg,min) <= fun(arg,list[1])) {
                    min = min;
                } else {
                    min = list[1];
                }
                return findIndex(fun,arg,tl,min);
            }
        };
        var found_color = findIndex(colorDistance, color, palette, palette[0]);
        return found_color;
    }

    /* *
     * Dithering algorithms
     *
     * orderedDither
     * atkinsonDither
     * errorDiffusionDither
     * */

    function orderedDither(in_imgdata, ctx, palette, step, w, h) {
        var out_imgdata = ctx.createImageData(in_imgdata);
        var d = new Uint8ClampedArray(in_imgdata.data);
        var ratio = 3;
        var m = new Array(
            [  1,  9,  3, 11 ],
            [ 13,  5, 15,  7 ],
            [  4, 12,  2, 10 ],
            [ 16,  8, 14,  6 ]
        );

        for (var y=0;y<h;y += step) {
            for (var x=0;x<w;x += step) {
                var i = (4*x) + (4*y*w);

                // Define bytes
                var r = i;
                var g = i+1;
                var b = i+2;
                var a = i+3;

                d[r] += m[x%4][y%4] * ratio;
                d[g] += m[x%4][y%4] * ratio;
                d[b] += m[x%4][y%4] * ratio;

                //var tr = threshold(d[r]);
                //var tg = threshold(d[g]);
                //var tb = threshold(d[b]);
                var color = new Array(d[r],d[g],d[b]);
                var approx = approximateColor(color, palette);
                var tr = approx[0];
                var tg = approx[1];
                var tb = approx[2];

                // d[r] = t;
                // d[g] = t;
                // d[b] = t;

                // Draw a block
                for (var dx=0;dx<step;dx++){
                    for (var dy=0;dy<step;dy++){
                        var di = i + (4 * dx) + (4 * w * dy);

                        // Draw pixel
                        d[di] = tr;
                        d[di+1] = tg;
                        d[di+2] = tb;

                    }
                }
            }
        }
        out_imgdata.data.set(d);
        return out_imgdata;
    };

	
    function atkinsonDither(in_imgdata, ctx, palette, step, h, w) {

        var out_imgdata = ctx.createImageData(in_imgdata);
        var d = new Uint8ClampedArray(in_imgdata.data);

		var fw=4*w;
        for (var y=0; y<h*w; y+=w) {
            for (var x=0; x<w; x += 1) {
                var i = 4*(x + y);

                // Define bytes
                var r = i;
                var g = i+1;
                var b = i+2;
                var a = i+3;

                //var approx = [d[r],d[g],d[b]];//approximateColor([d[r],d[g],d[b]], palette);
				var approx = approximateColor([d[r],d[g],d[b]], palette);

                var q = [];
                r = (d[r] - approx[0]) / 8;
                g = (d[g] - approx[1]) / 8;
                b = (d[b] - approx[2]) / 8;
	
				// Diffuse the error for three colors
				var n = 4*(x+1+y);
                d[n] += r;
                d[n+1] += g;
                d[n+2] += b;

                d[n+4] += r;
                d[n+5] += g;
                d[n+6] += b;
				n=n+fw-4;
                d[n] += r;
                d[n+1] += g;
                d[n+2] += b;

                d[n+4] += r;
                d[n+5] += g;
                d[n+6] += b;

                d[n+8] += r;
                d[n+9] += g;
                d[n+10] += b;
				n=n+fw+8;
                d[n] += r;
                d[n+1] += g;
                d[n+2] += b;


/*
				// Diffuse the error for three colors
				//var n = 4*(x+1+y);
                d[4*(x+y)+4 + 0] += r;
                d[4*(x+y)+4 + 1] += g;
                d[4*(x+y)+4 + 2] += b;

                d[4*(x+y)+8 + 0] += r;
                d[4*(x+y)+8 + 1] += g;
                d[4*(x+y)+8 + 2] += b;

                d[4*(x+y)+fw-4 + 0] += r;
                d[4*(x+y)+fw-4 + 1] += g;
                d[4*(x+y)+fw-4 + 2] += b;

                d[4*(x+y)+fw + 0] += r;
                d[4*(x+y)+fw + 1] += g;
                d[4*(x+y)+fw + 2] += b;

                d[4*(x+y)+fw+4 + 0] += r;
                d[4*(x+y)+fw+4 + 1] += g;
                d[4*(x+y)+fw+4 + 2] += b;

                d[4*(x+y)+fw+fw+4 + 0] += r;
                d[4*(x+y)+fw+fw+4 + 1] += g;
                d[4*(x+y)+fw+fw+4 + 2] += b;

                // Diffuse the error for three colors
                d[4*(x+1)+4*w*(y  ) + 0] += q[r];
                d[4*(x-1)+4*w*(y+1) + 0] += q[r];
                d[4*(x  )+4*w*(y+1) + 0] += q[r];
                d[4*(x+1)+4*w*(y+1) + 0] += q[r];
                d[4*(x+2)+4*w*(y  ) + 0] += q[r];
                d[4*(x  )+4*w*(y+2) + 0] += q[r];

                d[4*(x+1)+4*w*(y  ) + 1] += q[g];
                d[4*(x-1)+4*w*(y+1) + 1] += q[g];
                d[4*(x  )+4*w*(y+1) + 1] += q[g];
                d[4*(x+1)+4*w*(y+1) + 1] += q[g];
                d[4*(x+2)+4*w*(y  ) + 1] += q[g];
                d[4*(x  )+4*w*(y+2) + 1] += q[g];

                d[4*(x+1)+4*w*(y  ) + 2] += q[b];
                d[4*(x-1)+4*w*(y+1) + 2] += q[b];
                d[4*(x  )+4*w*(y+1) + 2] += q[b];
                d[4*(x+1)+4*w*(y+1) + 2] += q[b];
                d[4*(x+2)+4*w*(y  ) + 2] += q[b];
                d[4*(x  )+4*w*(y+2) + 2] += q[b];
*/
                        // Draw pixel
                        d[i  ] = approx[0];
                        d[i+1] = approx[1];
                        d[i+2] = approx[2];

				
            }
        }
		
        out_imgdata.data.set(d);
        return out_imgdata;
    };
	
    function atkinsonDitherOld(in_imgdata, ctx, palette, step, h, w) {
        var out_imgdata = ctx.createImageData(in_imgdata);
        var d = new Uint8ClampedArray(in_imgdata.data);
        var out = new Uint8ClampedArray(in_imgdata.data);
        var ratio = 1/8;

        for (var y=0;y<h;y += step) {
            for (var x=0;x<w;x += step) {
                var i = (4*x) + (4*y*w);

                var $i = function(x,y) {
                    return (4*x) + (4*y*w);
                };

                // Define bytes
                var r = i;
                var g = i+1;
                var b = i+2;
                var a = i+3;

                var color = new Array(d[r],d[g],d[b]);
                var approx = approximateColor(color, palette);

                var q = [];
                q[r] = d[r] - approx[0];
                q[g] = d[g] - approx[1];
                q[b] = d[b] - approx[2];

                // Diffuse the error for three colors
                d[$i(x+step,y) + 0] += ratio * q[r];
                d[$i(x-step,y+step) + 0] += ratio * q[r];
                d[$i(x,y+step) + 0] += ratio * q[r];
                d[$i(x+step,y+step) + 0] += ratio * q[r];
                d[$i(x+(2*step),y) + 0] += ratio * q[r];
                d[$i(x,y+(2*step)) + 0] += ratio * q[r];

                d[$i(x+step,y) + 1] += ratio * q[g];
                d[$i(x-step,y+step) + 1] += ratio * q[g];
                d[$i(x,y+step) + 1] += ratio * q[g];
                d[$i(x+step,y+step) + 1] += ratio * q[g];
                d[$i(x+(2*step),y) + 1] += ratio * q[g];
                d[$i(x,y+(2*step)) + 1] += ratio * q[g];

                d[$i(x+step,y) + 2] += ratio * q[b];
                d[$i(x-step,y+step) + 2] += ratio * q[b];
                d[$i(x,y+step) + 2] += ratio * q[b];
                d[$i(x+step,y+step) + 2] += ratio * q[b];
                d[$i(x+(2*step),y) + 2] += ratio * q[b];
                d[$i(x,y+(2*step)) + 2] += ratio * q[b];

                var tr = approx[0];
                var tg = approx[1];
                var tb = approx[2];

                // Draw a block
                for (var dx=0;dx<step;dx++){
                    for (var dy=0;dy<step;dy++){
                        var di = i + (4 * dx) + (4 * w * dy);

                        // Draw pixel
                        out[di] = tr;
                        out[di+1] = tg;
                        out[di+2] = tb;

                    }
                }
            }
        }
        out_imgdata.data.set(out);
        return out_imgdata;
    };

    function errorDiffusionDither(in_imgdata, ctx, palette, step, h, w) {
        var out_imgdata = ctx.createImageData(in_imgdata);
        var d = new Uint8ClampedArray(in_imgdata.data);
        var out = new Uint8ClampedArray(in_imgdata.data);
        var ratio = 1/16;
        var m = new Array(
            [  1,  9,  3, 11 ],
            [ 13,  5, 15,  7 ],
            [  4, 12,  2, 10 ],
            [ 16,  8, 14,  6 ]
        );

        for (var y=0;y<h;y += step) {
            for (var x=0;x<w;x += step) {
                var i = (4*x) + (4*y*w);

                var $i = function(x,y) {
                    return (4*x) + (4*y*w);
                };

                // Define bytes
                var r = i;
                var g = i+1;
                var b = i+2;
                var a = i+3;

                var color = new Array(d[r],d[g],d[b]);
                var approx = approximateColor(color, palette);

                var q = [];
                q[r] = d[r] - approx[0];
                q[g] = d[g] - approx[1];
                q[b] = d[b] - approx[2];

                // Diffuse the error
                d[$i(x+step,y)] =  d[$i(x+step,y)] + 7 * ratio * q[r];
                d[$i(x-step,y+1)] =  d[$i(x-1,y+step)] + 3 * ratio * q[r];
                d[$i(x,y+step)] =  d[$i(x,y+step)] + 5 * ratio * q[r];
                d[$i(x+step,y+step)] =  d[$i(x+1,y+step)] + 1 * ratio * q[r];

                d[$i(x+step,y)+1] =  d[$i(x+step,y)+1] + 7 * ratio * q[g];
                d[$i(x-step,y+step)+1] =  d[$i(x-step,y+step)+1] + 3 * ratio * q[g];
                d[$i(x,y+step)+1] =  d[$i(x,y+step)+1] + 5 * ratio * q[g];
                d[$i(x+step,y+step)+1] =  d[$i(x+step,y+step)+1] + 1 * ratio * q[g];

                d[$i(x+step,y)+2] =  d[$i(x+step,y)+2] + 7 * ratio * q[b];
                d[$i(x-step,y+step)+2] =  d[$i(x-step,y+step)+2] + 3 * ratio * q[b];
                d[$i(x,y+step)+2] =  d[$i(x,y+step)+2] + 5 * ratio * q[b];
                d[$i(x+step,y+step)+2] =  d[$i(x+step,y+step)+2] + 1 * ratio * q[b];

                // Color
                var tr = approx[0];
                var tg = approx[1];
                var tb = approx[2];

                // Draw a block
                for (var dx=0;dx<step;dx++){
                    for (var dy=0;dy<step;dy++){
                        var di = i + (4 * dx) + (4 * w * dy);

                        // Draw pixel
                        out[di] = tr;
                        out[di+1] = tg;
                        out[di+2] = tb;

                    }
                }
            }
        }
        out_imgdata.data.set(out);
        return out_imgdata;
    };
	
	function closestColor(in_imgdata, ctx, palette, step, h, w) {
		var out_imgdata = ctx.createImageData(in_imgdata);
        var out = new Uint8ClampedArray(in_imgdata.data);

        for (var i = 0; i < out.length; i += 4) {
            var approx = approximateColor([out[i], out[i + 1], out[i + 2]], palette);
            out[i]     = approx[0];
			out[i + 1] = approx[1];
			out[i + 2] = approx[2];
        }

        out_imgdata.data.set(out);
        return out_imgdata;
    };

    var DitherJS = function DitherJS (selector, opt) {
        var self = this;

        // Default
        self.opt = opt || {};
        self.opt.step = self.opt.step || 1; // works better with 1,3,5,7
        self.opt.className = self.opt.className || 'dither';
        self.opt.algorithm = self.opt.algorithm || 'ordered';
        self.opt.palette = self.opt.palette || [
            [0,0,0],
            [255,0,255],
            [0,255,255],
            [255,255,255]
        ];

        /**
        * Reload src image and put draw into it
        * */
        this._refreshDither = function(el) {
            // Reload src
            el.src = el.src + '?' + Math.random();
            el.onload = function() {
                var start_time = Date.now();
                self._dither(el);
                console.log('Microtime: ', Date.now()-start_time );
            }
        };

        /**
        * This does all the dirty things
        * */
        this._dither = function(el) {
            var ditherCtx = this;

            // Take image size
            var h = el.clientHeight;
            var w = el.clientWidth;


            /**
            * Threshold function
            * */
            var threshold = function(value) {
                var result = value < 127 ? 0 : 255;
                return result;
            };

            /**
            * Given an image element substitute it with a canvas
            * and return the context
            * @param node - the image element
            * @return context - drawing context
            * */
            this.getContext = function(el) {
                var canvas = document.createElement('canvas');
                // this can influence the quality of the acquistion
                canvas.height = el.clientHeight;
                canvas.width = el.clientWidth;
                el.parentNode.replaceChild(canvas,el);

                // Inherit classes
                canvas.className = el.className;
                canvas.className = canvas.className.replace(self.opt.className,' ');
                // Inherit Styles

                // Turn it off
                // canvas.style.visibility = "hidden";

                // Get the context
                var ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                return ctx;
            }


            var ctx = this.getContext(el);

            // Put the picture in
            ctx.drawImage(el,0,0,w,h);

            // Pick image data
            var in_image = ctx.getImageData(0,0,w,h);

            if (self.opt.algorithm == 'errorDiffusion')
                var out_image = errorDiffusionDither(in_image, ctx, self.opt.palette, self.opt.step, h, w);
            else if (self.opt.algorithm == 'ordered')
                var out_image = orderedDither(in_image, ctx, self.opt.palette, self.opt.step, h, w);
            else if (self.opt.algorithm == 'atkinson')
                var out_image = atkinsonDither(in_image, ctx, self.opt.palette, self.opt.step, h, w);
            else
                throw new Error('Not a valid algorithm');

            // Put image data
            ctx.putImageData(out_image,0,0);

            // Turn it on
            //canvas.style.visibility = "visible";
        }


        /**
        * Main
        * */
        try {
            var elements = document.querySelectorAll(selector);

            //  deal with multiple
            for (var i=0;i<elements.length;i++) {
                this._refreshDither(elements[i]);
            }

        } catch (e) {
            // Officially not in the browser
        }

    };

    DitherJS.orderedDither = orderedDither;
    DitherJS.atkinsonDither = atkinsonDither;
    DitherJS.errorDiffusionDither = errorDiffusionDither;
    DitherJS.closestColor = closestColor;
	DitherJS.atkinsonDitherOld = atkinsonDitherOld;

    return DitherJS;

})(window);

/**
* Register AMD module
* */
if (typeof define === 'function' && define.amd) {
    define('ditherjs', function(){
        return DitherJS;
    });
};

/**
* Export class for node
* */
if (typeof module === "object" && module.exports) {
    module.exports = DitherJS;
}



// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ //
// PNG for Pebble
////// adapted from https://github.com/wheany/js-png-encoder/blob/master/generatepng.js


(function(globalObj) {
    'use strict';
    var CRC_TABLE = [],
        SIGNATURE = String.fromCharCode(137, 80, 78, 71, 13, 10, 26, 10),
        NO_FILTER = 0,
        PEBBLE_PALETTE = [],
        
        make_crc_table = function() {
            var n, c, k;
            for (n = 0; n < 256; n++) {
                c = n;
                for (k = 0; k < 8; k++) {
                    if (c & 1) {
                        c = 0xedb88320 ^ (c >>> 1);
                    } else {
                        c = c >>> 1;
                    }
                }
                CRC_TABLE[n] = c;
            }
        },
        
        make_pebble_palette = function() {
            for(var i=0; i<64; i++){
                PEBBLE_PALETTE.push(((i >> 4) & 0x3) * 85);
                PEBBLE_PALETTE.push(((i >> 2) & 0x3) * 85);
                PEBBLE_PALETTE.push(((i >> 0) & 0x3) * 85);
            }
        },
        
        map_color_to_palette = function(palette, red, green, blue) {
            var diffR,diffG,diffB,diffDistance,mappedColor;
            var distance=3*0xFF*0xFF;
            for(var i=0;i<palette.length;i+=3){
                diffR=( palette[i]     - red );
                diffG=( palette[i+1]   - green );
                diffB=( palette[i+2]   - blue );
                diffDistance = diffR*diffR + diffG*diffG + diffB*diffB;
                if( diffDistance < distance  ){ 
                    distance=diffDistance; 
                    mappedColor=i/3; 
                }
            }
            return(mappedColor);
        },
        
        update_crc = function(crc, buf) {
            var c = crc,
                n, b;
            for (n = 0; n < buf.length; n++) {
                b = buf.charCodeAt(n);
                c = CRC_TABLE[(c ^ b) & 0xff] ^ (c >>> 8);
            }
            return c;
        },
        
        crc = function crc(buf) {
            return update_crc(0xffffffff, buf) ^ 0xffffffff;
        },
        
        dwordAsString = function(dword) {
            return String.fromCharCode((dword & 0xFF000000) >>> 24, (dword & 0x00FF0000) >>> 16, (dword & 0x0000FF00) >>> 8, (dword & 0x000000FF));
        },
        
        createChunk = function(length, type, data) {
            var CRC = crc(type + data);
            return dwordAsString(length) +
                type +
                data +
                dwordAsString(CRC);
        },
        
        IEND,
        
        createIHDR = function(width, height, bitdepth) {
            var IHDRdata;
            IHDRdata = dwordAsString(width);
            IHDRdata += dwordAsString(height);
            // bit depth
            IHDRdata += String.fromCharCode(bitdepth);
            // color type: 3=indexed
            IHDRdata += String.fromCharCode(3);
            // compression method: 0=deflate, only allowed value
            IHDRdata += String.fromCharCode(0);
            // filtering: 0=adaptive, only allowed value
            IHDRdata += String.fromCharCode(0);
            // interlacing: 0=none
            IHDRdata += String.fromCharCode(0);
            return createChunk(13, 'IHDR', IHDRdata);
        },
        
        png = function(width, height, rgb) {
            var IHDR,
                PLTE,
                IDAT,
                scanlines = '',
                y,
                x,
                compressedScanlines = '',
                png_palette = new Object(),
                png_palette_buff = '',
                paletteIdx = 0;

            var getColorIdx = function(red, green, blue) {
                var color = (((red << 8) | green) << 8) | blue;
                if (typeof png_palette[color] == "undefined") {
                    var mappedColorId = map_color_to_palette(PEBBLE_PALETTE, red, green, blue);
                    
                    red     = PEBBLE_PALETTE[3*mappedColorId + 0];
                    green   = PEBBLE_PALETTE[3*mappedColorId + 1];
                    blue    = PEBBLE_PALETTE[3*mappedColorId + 2];

                    var color_to_pebble = (((red << 8) | green) << 8) | blue;
                    if (typeof png_palette[color_to_pebble] == "undefined") {
                        png_palette_buff += String.fromCharCode(red);
                        png_palette_buff += String.fromCharCode(green);
                        png_palette_buff += String.fromCharCode(blue);
                        png_palette[color_to_pebble] = paletteIdx++;
                    }
                    png_palette[color] = png_palette[color_to_pebble];
                    
                }
                return png_palette[color];
            }

            var numcomponents = rgb.length / (height*width);

            // compute the reduced palette
            for (y = 0; y < height*width; y++) {
                getColorIdx(rgb[numcomponents * y] & 0xff, rgb[numcomponents * y + 1] & 0xff, rgb[numcomponents * y + 2] & 0xff);
            }

            var nb_colors = png_palette_buff.length / 3;
            var bitdepth  = 1;
            if(nb_colors > 16){
                bitdepth = 8;
            }
            else if(nb_colors > 4){
                bitdepth = 4;
            }
            else if(nb_colors > 2){
                bitdepth = 2;
            }
                    
            var scanlines_arr = [];
            var curr_byte  = 0;
            var bit_offset = 0;
                
            for (y = 0; y < height; y++) {
                scanlines_arr.push(NO_FILTER);
                bit_offset = 0;
                curr_byte  = 0;
                for (x = 0; x < width; x++) {
                    bit_offset += bitdepth;
                    curr_byte  += getColorIdx(rgb[numcomponents * (y * width + x)] & 0xff, rgb[numcomponents * (y * width + x) + 1] & 0xff, rgb[numcomponents * (y * width + x) + 2] & 0xff) << (8 - bit_offset);
                    if(bit_offset == 8){
                        scanlines_arr.push(curr_byte);
                        curr_byte   = 0;
                        bit_offset  = 0;
                    }
                }
                if(bit_offset > 0){
                    scanlines_arr.push(curr_byte);
                }
            }

            var compressed = new Zlib.Deflate(scanlines_arr).compress();
            for (var i = 0; i < compressed.length; i++) {
                compressedScanlines += String.fromCharCode(compressed[i]);
            }

            IHDR = createIHDR(width, height, bitdepth);
            PLTE = createChunk(png_palette_buff.length, 'PLTE', png_palette_buff);
            IDAT = createChunk(compressedScanlines.length, 'IDAT', compressedScanlines);
            return SIGNATURE + IHDR + PLTE + IDAT + IEND;
        };
  
    make_crc_table();
    make_pebble_palette();
    IEND = createChunk(0, 'IEND', '');
    globalObj.generatePngForPebble = png;
}(this));
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ //
// Zlib Deflate.min.js	
/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function() {'use strict';var n=void 0,w=!0,aa=this;function ba(f,d){var c=f.split("."),e=aa;!(c[0]in e)&&e.execScript&&e.execScript("var "+c[0]);for(var b;c.length&&(b=c.shift());)!c.length&&d!==n?e[b]=d:e=e[b]?e[b]:e[b]={}};var C="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array&&"undefined"!==typeof DataView;function K(f,d){this.index="number"===typeof d?d:0;this.e=0;this.buffer=f instanceof(C?Uint8Array:Array)?f:new (C?Uint8Array:Array)(32768);if(2*this.buffer.length<=this.index)throw Error("invalid index");this.buffer.length<=this.index&&ca(this)}function ca(f){var d=f.buffer,c,e=d.length,b=new (C?Uint8Array:Array)(e<<1);if(C)b.set(d);else for(c=0;c<e;++c)b[c]=d[c];return f.buffer=b}
K.prototype.b=function(f,d,c){var e=this.buffer,b=this.index,a=this.e,g=e[b],m;c&&1<d&&(f=8<d?(L[f&255]<<24|L[f>>>8&255]<<16|L[f>>>16&255]<<8|L[f>>>24&255])>>32-d:L[f]>>8-d);if(8>d+a)g=g<<d|f,a+=d;else for(m=0;m<d;++m)g=g<<1|f>>d-m-1&1,8===++a&&(a=0,e[b++]=L[g],g=0,b===e.length&&(e=ca(this)));e[b]=g;this.buffer=e;this.e=a;this.index=b};K.prototype.finish=function(){var f=this.buffer,d=this.index,c;0<this.e&&(f[d]<<=8-this.e,f[d]=L[f[d]],d++);C?c=f.subarray(0,d):(f.length=d,c=f);return c};
var da=new (C?Uint8Array:Array)(256),M;for(M=0;256>M;++M){for(var N=M,S=N,ea=7,N=N>>>1;N;N>>>=1)S<<=1,S|=N&1,--ea;da[M]=(S<<ea&255)>>>0}var L=da;function ia(f){this.buffer=new (C?Uint16Array:Array)(2*f);this.length=0}ia.prototype.getParent=function(f){return 2*((f-2)/4|0)};ia.prototype.push=function(f,d){var c,e,b=this.buffer,a;c=this.length;b[this.length++]=d;for(b[this.length++]=f;0<c;)if(e=this.getParent(c),b[c]>b[e])a=b[c],b[c]=b[e],b[e]=a,a=b[c+1],b[c+1]=b[e+1],b[e+1]=a,c=e;else break;return this.length};
ia.prototype.pop=function(){var f,d,c=this.buffer,e,b,a;d=c[0];f=c[1];this.length-=2;c[0]=c[this.length];c[1]=c[this.length+1];for(a=0;;){b=2*a+2;if(b>=this.length)break;b+2<this.length&&c[b+2]>c[b]&&(b+=2);if(c[b]>c[a])e=c[a],c[a]=c[b],c[b]=e,e=c[a+1],c[a+1]=c[b+1],c[b+1]=e;else break;a=b}return{index:f,value:d,length:this.length}};function ka(f,d){this.d=la;this.i=0;this.input=C&&f instanceof Array?new Uint8Array(f):f;this.c=0;d&&(d.lazy&&(this.i=d.lazy),"number"===typeof d.compressionType&&(this.d=d.compressionType),d.outputBuffer&&(this.a=C&&d.outputBuffer instanceof Array?new Uint8Array(d.outputBuffer):d.outputBuffer),"number"===typeof d.outputIndex&&(this.c=d.outputIndex));this.a||(this.a=new (C?Uint8Array:Array)(32768))}var la=2,na={NONE:0,h:1,g:la,n:3},T=[],U;
for(U=0;288>U;U++)switch(w){case 143>=U:T.push([U+48,8]);break;case 255>=U:T.push([U-144+400,9]);break;case 279>=U:T.push([U-256+0,7]);break;case 287>=U:T.push([U-280+192,8]);break;default:throw"invalid literal: "+U;}
ka.prototype.f=function(){var f,d,c,e,b=this.input;switch(this.d){case 0:c=0;for(e=b.length;c<e;){d=C?b.subarray(c,c+65535):b.slice(c,c+65535);c+=d.length;var a=d,g=c===e,m=n,k=n,p=n,t=n,u=n,l=this.a,h=this.c;if(C){for(l=new Uint8Array(this.a.buffer);l.length<=h+a.length+5;)l=new Uint8Array(l.length<<1);l.set(this.a)}m=g?1:0;l[h++]=m|0;k=a.length;p=~k+65536&65535;l[h++]=k&255;l[h++]=k>>>8&255;l[h++]=p&255;l[h++]=p>>>8&255;if(C)l.set(a,h),h+=a.length,l=l.subarray(0,h);else{t=0;for(u=a.length;t<u;++t)l[h++]=
a[t];l.length=h}this.c=h;this.a=l}break;case 1:var q=new K(C?new Uint8Array(this.a.buffer):this.a,this.c);q.b(1,1,w);q.b(1,2,w);var s=oa(this,b),x,fa,z;x=0;for(fa=s.length;x<fa;x++)if(z=s[x],K.prototype.b.apply(q,T[z]),256<z)q.b(s[++x],s[++x],w),q.b(s[++x],5),q.b(s[++x],s[++x],w);else if(256===z)break;this.a=q.finish();this.c=this.a.length;break;case la:var B=new K(C?new Uint8Array(this.a.buffer):this.a,this.c),ta,J,O,P,Q,La=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],X,ua,Y,va,ga,ja=Array(19),
wa,R,ha,y,xa;ta=la;B.b(1,1,w);B.b(ta,2,w);J=oa(this,b);X=pa(this.m,15);ua=qa(X);Y=pa(this.l,7);va=qa(Y);for(O=286;257<O&&0===X[O-1];O--);for(P=30;1<P&&0===Y[P-1];P--);var ya=O,za=P,F=new (C?Uint32Array:Array)(ya+za),r,G,v,Z,E=new (C?Uint32Array:Array)(316),D,A,H=new (C?Uint8Array:Array)(19);for(r=G=0;r<ya;r++)F[G++]=X[r];for(r=0;r<za;r++)F[G++]=Y[r];if(!C){r=0;for(Z=H.length;r<Z;++r)H[r]=0}r=D=0;for(Z=F.length;r<Z;r+=G){for(G=1;r+G<Z&&F[r+G]===F[r];++G);v=G;if(0===F[r])if(3>v)for(;0<v--;)E[D++]=0,
H[0]++;else for(;0<v;)A=138>v?v:138,A>v-3&&A<v&&(A=v-3),10>=A?(E[D++]=17,E[D++]=A-3,H[17]++):(E[D++]=18,E[D++]=A-11,H[18]++),v-=A;else if(E[D++]=F[r],H[F[r]]++,v--,3>v)for(;0<v--;)E[D++]=F[r],H[F[r]]++;else for(;0<v;)A=6>v?v:6,A>v-3&&A<v&&(A=v-3),E[D++]=16,E[D++]=A-3,H[16]++,v-=A}f=C?E.subarray(0,D):E.slice(0,D);ga=pa(H,7);for(y=0;19>y;y++)ja[y]=ga[La[y]];for(Q=19;4<Q&&0===ja[Q-1];Q--);wa=qa(ga);B.b(O-257,5,w);B.b(P-1,5,w);B.b(Q-4,4,w);for(y=0;y<Q;y++)B.b(ja[y],3,w);y=0;for(xa=f.length;y<xa;y++)if(R=
f[y],B.b(wa[R],ga[R],w),16<=R){y++;switch(R){case 16:ha=2;break;case 17:ha=3;break;case 18:ha=7;break;default:throw"invalid code: "+R;}B.b(f[y],ha,w)}var Aa=[ua,X],Ba=[va,Y],I,Ca,$,ma,Da,Ea,Fa,Ga;Da=Aa[0];Ea=Aa[1];Fa=Ba[0];Ga=Ba[1];I=0;for(Ca=J.length;I<Ca;++I)if($=J[I],B.b(Da[$],Ea[$],w),256<$)B.b(J[++I],J[++I],w),ma=J[++I],B.b(Fa[ma],Ga[ma],w),B.b(J[++I],J[++I],w);else if(256===$)break;this.a=B.finish();this.c=this.a.length;break;default:throw"invalid compression type";}return this.a};
function ra(f,d){this.length=f;this.k=d}
var sa=function(){function f(b){switch(w){case 3===b:return[257,b-3,0];case 4===b:return[258,b-4,0];case 5===b:return[259,b-5,0];case 6===b:return[260,b-6,0];case 7===b:return[261,b-7,0];case 8===b:return[262,b-8,0];case 9===b:return[263,b-9,0];case 10===b:return[264,b-10,0];case 12>=b:return[265,b-11,1];case 14>=b:return[266,b-13,1];case 16>=b:return[267,b-15,1];case 18>=b:return[268,b-17,1];case 22>=b:return[269,b-19,2];case 26>=b:return[270,b-23,2];case 30>=b:return[271,b-27,2];case 34>=b:return[272,
b-31,2];case 42>=b:return[273,b-35,3];case 50>=b:return[274,b-43,3];case 58>=b:return[275,b-51,3];case 66>=b:return[276,b-59,3];case 82>=b:return[277,b-67,4];case 98>=b:return[278,b-83,4];case 114>=b:return[279,b-99,4];case 130>=b:return[280,b-115,4];case 162>=b:return[281,b-131,5];case 194>=b:return[282,b-163,5];case 226>=b:return[283,b-195,5];case 257>=b:return[284,b-227,5];case 258===b:return[285,b-258,0];default:throw"invalid length: "+b;}}var d=[],c,e;for(c=3;258>=c;c++)e=f(c),d[c]=e[2]<<24|
e[1]<<16|e[0];return d}(),Ha=C?new Uint32Array(sa):sa;
function oa(f,d){function c(b,c){var a=b.k,d=[],e=0,f;f=Ha[b.length];d[e++]=f&65535;d[e++]=f>>16&255;d[e++]=f>>24;var g;switch(w){case 1===a:g=[0,a-1,0];break;case 2===a:g=[1,a-2,0];break;case 3===a:g=[2,a-3,0];break;case 4===a:g=[3,a-4,0];break;case 6>=a:g=[4,a-5,1];break;case 8>=a:g=[5,a-7,1];break;case 12>=a:g=[6,a-9,2];break;case 16>=a:g=[7,a-13,2];break;case 24>=a:g=[8,a-17,3];break;case 32>=a:g=[9,a-25,3];break;case 48>=a:g=[10,a-33,4];break;case 64>=a:g=[11,a-49,4];break;case 96>=a:g=[12,a-
65,5];break;case 128>=a:g=[13,a-97,5];break;case 192>=a:g=[14,a-129,6];break;case 256>=a:g=[15,a-193,6];break;case 384>=a:g=[16,a-257,7];break;case 512>=a:g=[17,a-385,7];break;case 768>=a:g=[18,a-513,8];break;case 1024>=a:g=[19,a-769,8];break;case 1536>=a:g=[20,a-1025,9];break;case 2048>=a:g=[21,a-1537,9];break;case 3072>=a:g=[22,a-2049,10];break;case 4096>=a:g=[23,a-3073,10];break;case 6144>=a:g=[24,a-4097,11];break;case 8192>=a:g=[25,a-6145,11];break;case 12288>=a:g=[26,a-8193,12];break;case 16384>=
a:g=[27,a-12289,12];break;case 24576>=a:g=[28,a-16385,13];break;case 32768>=a:g=[29,a-24577,13];break;default:throw"invalid distance";}f=g;d[e++]=f[0];d[e++]=f[1];d[e++]=f[2];var k,m;k=0;for(m=d.length;k<m;++k)l[h++]=d[k];s[d[0]]++;x[d[3]]++;q=b.length+c-1;u=null}var e,b,a,g,m,k={},p,t,u,l=C?new Uint16Array(2*d.length):[],h=0,q=0,s=new (C?Uint32Array:Array)(286),x=new (C?Uint32Array:Array)(30),fa=f.i,z;if(!C){for(a=0;285>=a;)s[a++]=0;for(a=0;29>=a;)x[a++]=0}s[256]=1;e=0;for(b=d.length;e<b;++e){a=
m=0;for(g=3;a<g&&e+a!==b;++a)m=m<<8|d[e+a];k[m]===n&&(k[m]=[]);p=k[m];if(!(0<q--)){for(;0<p.length&&32768<e-p[0];)p.shift();if(e+3>=b){u&&c(u,-1);a=0;for(g=b-e;a<g;++a)z=d[e+a],l[h++]=z,++s[z];break}0<p.length?(t=Ia(d,e,p),u?u.length<t.length?(z=d[e-1],l[h++]=z,++s[z],c(t,0)):c(u,-1):t.length<fa?u=t:c(t,0)):u?c(u,-1):(z=d[e],l[h++]=z,++s[z])}p.push(e)}l[h++]=256;s[256]++;f.m=s;f.l=x;return C?l.subarray(0,h):l}
function Ia(f,d,c){var e,b,a=0,g,m,k,p,t=f.length;m=0;p=c.length;a:for(;m<p;m++){e=c[p-m-1];g=3;if(3<a){for(k=a;3<k;k--)if(f[e+k-1]!==f[d+k-1])continue a;g=a}for(;258>g&&d+g<t&&f[e+g]===f[d+g];)++g;g>a&&(b=e,a=g);if(258===g)break}return new ra(a,d-b)}
function pa(f,d){var c=f.length,e=new ia(572),b=new (C?Uint8Array:Array)(c),a,g,m,k,p;if(!C)for(k=0;k<c;k++)b[k]=0;for(k=0;k<c;++k)0<f[k]&&e.push(k,f[k]);a=Array(e.length/2);g=new (C?Uint32Array:Array)(e.length/2);if(1===a.length)return b[e.pop().index]=1,b;k=0;for(p=e.length/2;k<p;++k)a[k]=e.pop(),g[k]=a[k].value;m=Ja(g,g.length,d);k=0;for(p=a.length;k<p;++k)b[a[k].index]=m[k];return b}
function Ja(f,d,c){function e(a){var b=k[a][p[a]];b===d?(e(a+1),e(a+1)):--g[b];++p[a]}var b=new (C?Uint16Array:Array)(c),a=new (C?Uint8Array:Array)(c),g=new (C?Uint8Array:Array)(d),m=Array(c),k=Array(c),p=Array(c),t=(1<<c)-d,u=1<<c-1,l,h,q,s,x;b[c-1]=d;for(h=0;h<c;++h)t<u?a[h]=0:(a[h]=1,t-=u),t<<=1,b[c-2-h]=(b[c-1-h]/2|0)+d;b[0]=a[0];m[0]=Array(b[0]);k[0]=Array(b[0]);for(h=1;h<c;++h)b[h]>2*b[h-1]+a[h]&&(b[h]=2*b[h-1]+a[h]),m[h]=Array(b[h]),k[h]=Array(b[h]);for(l=0;l<d;++l)g[l]=c;for(q=0;q<b[c-1];++q)m[c-
1][q]=f[q],k[c-1][q]=q;for(l=0;l<c;++l)p[l]=0;1===a[c-1]&&(--g[0],++p[c-1]);for(h=c-2;0<=h;--h){s=l=0;x=p[h+1];for(q=0;q<b[h];q++)s=m[h+1][x]+m[h+1][x+1],s>f[l]?(m[h][q]=s,k[h][q]=d,x+=2):(m[h][q]=f[l],k[h][q]=l,++l);p[h]=0;1===a[h]&&e(h)}return g}
function qa(f){var d=new (C?Uint16Array:Array)(f.length),c=[],e=[],b=0,a,g,m,k;a=0;for(g=f.length;a<g;a++)c[f[a]]=(c[f[a]]|0)+1;a=1;for(g=16;a<=g;a++)e[a]=b,b+=c[a]|0,b<<=1;a=0;for(g=f.length;a<g;a++){b=e[f[a]];e[f[a]]+=1;m=d[a]=0;for(k=f[a];m<k;m++)d[a]=d[a]<<1|b&1,b>>>=1}return d};function Ka(f,d){this.input=f;this.a=new (C?Uint8Array:Array)(32768);this.d=V.g;var c={},e;if((d||!(d={}))&&"number"===typeof d.compressionType)this.d=d.compressionType;for(e in d)c[e]=d[e];c.outputBuffer=this.a;this.j=new ka(this.input,c)}var V=na;
Ka.prototype.f=function(){var f,d,c,e,b,a,g=0;a=this.a;switch(8){case 8:f=Math.LOG2E*Math.log(32768)-8;break;default:throw Error("invalid compression method");}d=f<<4|8;a[g++]=d;switch(8){case 8:switch(this.d){case V.NONE:e=0;break;case V.h:e=1;break;case V.g:e=2;break;default:throw Error("unsupported compression type");}break;default:throw Error("invalid compression method");}c=e<<6|0;a[g++]=c|31-(256*d+c)%31;var m=this.input;if("string"===typeof m){var k=m.split(""),p,t;p=0;for(t=k.length;p<t;p++)k[p]=
(k[p].charCodeAt(0)&255)>>>0;m=k}for(var u=1,l=0,h=m.length,q,s=0;0<h;){q=1024<h?1024:h;h-=q;do u+=m[s++],l+=u;while(--q);u%=65521;l%=65521}b=(l<<16|u)>>>0;this.j.c=g;a=this.j.f();g=a.length;C&&(a=new Uint8Array(a.buffer),a.length<=g+4&&(this.a=new Uint8Array(a.length+4),this.a.set(a),a=this.a),a=a.subarray(0,g+4));a[g++]=b>>24&255;a[g++]=b>>16&255;a[g++]=b>>8&255;a[g++]=b&255;return a};ba("Zlib.Deflate",Ka);ba("Zlib.Deflate.compress",function(f,d){return(new Ka(f,d)).f()});ba("Zlib.Deflate.prototype.compress",Ka.prototype.f);var Ma={NONE:V.NONE,FIXED:V.h,DYNAMIC:V.g},Na,Oa,W,Pa;if(Object.keys)Na=Object.keys(Ma);else for(Oa in Na=[],W=0,Ma)Na[W++]=Oa;W=0;for(Pa=Na.length;W<Pa;++W)Oa=Na[W],ba("Zlib.Deflate.CompressionType."+Oa,Ma[Oa]);}).call(this); //@ sourceMappingURL=deflate.min.js.map
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ //




		</script>
	</body>
</html>